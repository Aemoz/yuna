# The kernel header

从这一节开始，我们来构建内核的头部。就像之前说过的，它从 loader 接手硬件的控制权，正式为内核设置必要的数据结构，并把硬件的控制权转交给内核。

基于目前我们掌握的知识，有哪些数据结构需要为内核设置呢？希望你还记得，它们分别是：GDT / IDT / 页表，我们从头开始看。

## 刷新段寄存器

由于 loader 为内核设置了 64 位模式下的 GDT，并完成了跳转，因此，在 head.S 的一开始，我们要先更新所有的数据段寄存器：

```asm
.section .text

.global _start // Help linker recognizes this symbol

_start:
    mov $0x10, %ax
    mov %ax, %ds
    mov %ax, %es
    mov %ax, %fs
    mov %ax, %ss
    mov $0x7E00, %esp
```

这次，我们使用了 AT&T 格式的汇编，它和之前我们使用 nasm 时的 Intel 格式汇编风格大相径庭。不过别担心，我们就这样边看代码，边把要用的知识补充一下。

首先，用 `.section .text` 定义了接下来的内容，都属于代码段。在代码段里，定义了一个全局符号 `_start`，正是因为这个定义，我们才能在链接脚本中使用 `ENTRY(_start)` 命令把它作为内核入口位置。

至于接下来的汇编指令，含义相信大家都没什么问题了，就是给数据段寄存器都加载上临时 GDT 的数据段描述符。但语法上：

* AT&T 语法的操作数顺序是左向右，第一个操作数是源，第二个操作数是目的。这和 Intel 语法是完全相反的；
* AT&T 中表示立即数要在前面加 `$`，例如 `$0x10`，`$0x7E00`；
* AT&T 中表示寄存器要在前面加 `%`，例如 `%ax`；

现在，大家应该知道为什么在写引导扇区的时候我说 Intel 格式的汇编语言简单了吧。不过，这也只是个开始，GCC 内连汇编的 AT&T 语法更麻烦，不过好在我们用也得不多，大家先记住这些语法就好了。

## 使用内核正式的 GDT 和 IDT

刷新了段寄存器后，我们在 head.S 中为内核设置正式的 GDT 和 IDT。这个所谓的正式 GDT 和 IDT 和之前在 loader 中设置的有什么不同呢？实话说，在现在这个阶段，没什么不同，同样是设置 64 位模式下内核的代码段和数据段，同样是一个假的 IDT。

但随着开发的深入，我们还要为用户空间的代码设置代码段和数据段，还要真的为 CPU 的中断和异常设置 IDT，这些都隶属于内核的一部分。届时，head.S 中的 GDT 和 IDT 就和 loader 中的不同了。

为此，我们还要添加一个已初始化数据段，存放这些必要的数据结构：

```asm
.align 8

.section .data
.global gdt
gdt:
    .quad 0x0000000000000000
    .quad 0x0020980000000000
    .quad 0x0000920000000000
gdt_end:

gdt_ptr:
    .word gdt_end - gdt - 1
    .quad gdt

.global idt
idt:
    .fill 512, 8, 0
idt_end:

idt_ptr:
    .word idt_end - idt - 1
    .quad idt
```

在上面的代码里，由于 GDT 每个表项占用 8 字节，因此，我们通过 `ALIGN` 命令，让这部分数据段在 8 字节地址上对齐。然后，用 `section .data` 表示下面的内容都属于已初始化数据段的内容。在这个段里，我们定义了两个全局符号 `gdt` 和 `idt`，方便稍后在内核代码中使用。

至于当前 `gdt` 和 `idt` 中的内容，和 loader 为内核设置的是完全一样的，我们就不重复了。

准备好这些数据之后，我们用下面的语法装载 CPU 的 GDTR 和 IDTR：

```asm
lgdt gdt_ptr(%rip)
lidt idt_ptr(%rip)
```

同样，它们执行的逻辑很好理解，但语法上有一点要特别说明：`gdt_ptr(%rip)` 这种基于 `rip` 指定地址的形式，是 64 位汇编新加入的，它叫做 RIP-Relative。在这种模式下，可以把 `rip` 理解为是基地址，`()` 外面的值，理解成是基于 `rip` 的偏移。因此，`gdt_ptr(%rip)` 的含义，就是基于 `rip` 计算访问 `gdt_ptr` 这个变量的地址，这和我们在 32 位汇编中直接使用符号地址的方法是完全不同的。

加载完 GDTR 和 IDTR 之后，同样，我们还是要刷新一遍所有的数据段寄存器。这和刚从 loader 接手过来时是一样的：

```asm
mov $0x10, %ax
mov %ax, %ds
mov %ax, %es
mov %ax, %fs
mov %ax, %ss
mov $0x7E00, %rsp
```

## 为内核正式设置页表

接下来，我们给内核换上正式的页表。之前我们说过，在 64 位模式下，我们使用的是 4级页表，页大小使用的是 2MB。为此，先来看 PML4 的部分：

```asm
.align 8

.org 0x1000 // 0x101000
_PML4:
    .quad 0x102003 // 0x00000000,00000000
    .fill 255, 8, 0
    .quad 0x102003 // 0xFFFF8000,00000000
    .fill 255, 8, 0
```

我们用 `.org` 命令把 `_PML4` 的起始地址设定在了 `0x1000`，由于内核加载的基地址是 `0x100000`，因此，`_PML4` 的物理地址就是 `0x101000`。在 `_PML4` 里，第 0 条和第 257 条记录是我们特别安排的。这两条记录对应着线性地址：`0x00000000,00000000` 和 `0xFFFF8000,00000000` 中对应的部分。也就是我们划分的低地址空间和高地址空间。由于线性地址中一共有 9 个 bit 索引 `_PML4`，因此，其余 510 个表项，我们用 `.fill` 命令，填充成 0。

`_PML4` 中第 0 条和第 257 条记录实际引用的页目录指针地址，是一样的，在物理地址 `0x102000` 处。为此，我们需要用 `.org 0x2000` 定义这个表：

```asm
.org 0x2000
_PDPTR:
    .quad 0x103003
    .fill 511, 0, 0
```

它只包含了一条有用的记录，索引位置是 0。因此，只有线性地址 bit 20-38 为 0 的地址是可访问的。其余的表项，我们用 `.fill` 填充成 0。通过页目录指针不难发现，页目录地址地址，安排在了 `0x103000`。因此，我们用 `org 0x3000` 定义页目录：

```asm
.org 0x3000
_PDE:
    .quad 0x000083
    .quad 0x200083
    .quad 0x400083
    .quad 0x600083
    .quad 0x800083
    .quad 0xe0000083 // Frame buffer
    .quad 0xe0200083
    .quad 0xe0400083
    .quad 0xe0600083
    .quad 0xe0800083
    .quad 0xe0a00083
    .quad 0xe0c00083
    .quad 0xe0e00083
    .fill 499, 8, 0
```

在页目录里，我们定义了 13 条记录。其中，前 5 条记录用于映射低 10MB 物理地址空间。从第 6 条记录开始，映射 `0xE0000000` 物理地址。这是 VBE 0x180 模式的 frame buffer 地址。稍后，我们往这个地址写东西，就可以在屏幕上显示出来了。这里，我们提前说一句，对于内核来说，为了使用页目录的第 6 条记录，线性地址是 `0xFFFF800000A00000`，也就是说，这是内核地址空间中 frame buffer 的线性地址，大家可以按照线性地址的划分自己算一下。

至此，内核的分页数据结构就设置好了。我们把 `_PML4` 的物理地址加载的 `CR3` 寄存器：

```asm
movq $0x101000, %rax
movq %rax, %cr3
```

这里，`movq` 又是 AT&T 特有的汇编语法，它要求我们给 CPU 指令后面加上表达操作数长度：

* `b` 表示字节；
* `w` 表示双字节；
* `l` 表示四字节；
* `q` 表示八字节；

## 另类的跳转指令

给 CPU 设置了新的页表结构之后，我们要执行一个跳转语句清空 CPU 的指令预取缓存。但遗憾的是，之前在 32 位模式使用的远跳转指令：

```asm
jmp code64_sel:KERNEL_OFFSET ; Invalid in 64 bit mode
```

`as` 不支持在 64 位模式里使用。为了在 64 位模式中实现跳转，我们得借助另外一种“移动”到代码其它位置的方法，也就是 `ret` 指令。什么意思呢？简单来说，当我们调用一个函数的时候，CPU 会把函数返回的位置先压栈，等到函数返回执行 `ret` 指令的时候，会从栈中找到要返回的位置。于是，我们只要手工在栈里构建一个所谓的“返回地址”，然后执行 `ret` 指令，就能变向实现跳转了。这段代码写出来，是这样的：

```asm
    movq _kernel_64bit_code(%rip), %rax
    pushq $0x08
    pushq %rax
    lretq // Simulate jmp 0x08:_kernel_64bit_code

    // kernel 64-bit code
_kernel_64bit_code:
    .quad _entry64
_entry64:
    mov $0x10, %ax
    mov %ax, %ds
    mov %ax, %es
    mov %ax, %fs
    mov %ax, %ss
```

`_entry64` 的位置，是要“跳转”的目标地址，在这里我们刷新了所有数据段寄存器。接下来，我们先用 RIP relative 的方式把这个地址保存在 `rax` 寄存器里，再把代码段的 selector 和 offset 压栈，这样就人为构建了一个返回地址。当我们执行 `lretq` 指令时，就返回到我们期望的地址执行了。

> 关于在栈中构建返回地址的这种做法，我们还要额外说一句。`rip` 中是 CPU 要执行的**下一条指令的地址**。因此入栈的是 `_kernel_64bit_code` 的地址，这个地址的值才是 `_entry64`。

## 跳转到 C 的入口函数

再一次刷新了数据段寄存器之后，我们就要跳转到　C 的入口函数了，和之前跳转到 `_entry64` 类似，这也要通过一个返回指令完成：

```asm
    movq _jump_to_kernel(%rip), %rax
    pushq $0x08
    pushq %rax
    lretq

_jump_to_kernel:
    .quad Start_Kernel
```

思路其实是一样的，我们就不重复了。

## What's next

在最后的这段代码中，`Start_Kernel` 是定义在 main.c 中的一个全局函数。因此，最后的这个 `lretq` 指令，对我们意义重大，自此，我们终于可以用 C 继续完成内核了。下一节，我们就来编写一个最简单的 main.c，并介绍给大家一种调试内核 C 代码的方法。
