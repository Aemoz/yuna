# The kernel file arch

我们之前说过，内核的二进制结构，要比之前编写的 boot.bin 或 loader.bin 复杂的多，我们需要准确定位一些内核中关键数据的位置。换句话说，内核是一个有结构的二进制文件。它看起来大致是这样子的：

```shell

  ▲ ┌────────────────────◀───── FFFF000000100000  
  │ │       head.o       │
  │ ├────────────────────┤
  │ │      printk.o      │
  │ ├────────────────────┤
  │ │    interrupt.o     │
Code├────────────────────┤
  │ │      device.o      │
  │ ├────────────────────┤
  │ │        ...         │
  │ ├────────────────────┤
  │ │       main.o       │
  ▼ ├────────────────────┤
  ▲ │        data        │
  │ ├────────────────────┤
Data│        bss         │
  │ ├────────────────────┤
  │ │        ...         │
  ▼ └────────────────────┘
```

从大的方面说，它包含了两部分内容：头部的代码（Code）部分，以及后面的数据（Data）部分。

为了能从 loader 跳转到内核，内核的头部必须加载到一个确定的地址上。对于我们来说，就是 1MB 的起始地址。在之前实现的 loader 中，我们通过页表，把 FFFF000000100000 这个地址映射到了物理地址 0x100000。因此，内核文件中，所有符号的地址，都应该基于 FFFF000000100000 这个地址计算。这个处在高位的地址空间，将专门用于操作系统内核。

接下来，操作系统的每一部分功能组件，都将独立编译成一个目标文件，也就是上面图中各种以 .o 结尾的文件。这里，我们先着重说两个：

* 一个是 head.o：这是内核的“头部”，也就是从 loader 接手了硬件控制权之后的代码，它主要的工作，就是为内核设置各种必要的数据结构；
* 一个是 main.o：这是内核的“功能入口”，head.o 中的代码执行完毕后，就会跳转到这里，初始化各种功能组件，并为用户提供服务。这里，也是汇编和 C 交界的地方，从这里开始，我们将主要使用 C 语言编程。这绝对是个令人开心的事情，因为汇编真的太难写和难以调试了 :)

至于内核的数据部分，则主要是已初始化数据（data）和未初始化数据（bss），编译器会在构建内核的时候自动帮我们处理这些内容，我们知道就好了。

## 理解链接脚本

理解了上面这个结构之后，接下来的问题就是，怎么把内核构建成上面那个样子呢？其实，这个问题说的更一般一点，你是不是想过：IDE 是如何把代码变成各种形式的可执行程序的呢？从 Windows 上的 PE，Linux 上的 ELF，以及 mac OS 上 Mach-O。其实，这个工作是通过链接器，例如：GNU 工具链中的 `ld` 程序，完成的。就像我们可以通过 Makefile 控制编译过程一样，链接器也支持通过自定义脚本控制，这就是所谓的链接脚本，它指挥链接器如何把多个目标文件中的相同的二进制段组合在一起。

我们使用的链接脚本，[是这样的](https://github.com/puretears/yuna/blob/master/Source/Kernel/kernel.lds)：

```shell
OUTPUT_FORMAT("elf64-x86-64")
ENTRY(_start)

SECTIONS
{
    . = 0xFFFF800000000000 + 0x100000;

    .text :
    {
        _text = .;
        *(.text)
        _etext = .;
    }

    . = ALIGN(8);

    .data :
    {
        _data = .;
        *(.data)
        _edata = .;
    }

    .rodata :
    {
        _rodata = .;
        *(.rodata)
        _erodata = .;
    }

    .bss :
    {
        _bss = .;
        *(.bss)
        _ebss = .;
    }

    _end = .;
}
```

其中：

* `OUTPUT_FORMAT("elf64-x86-64")` 用于定义链接器生成的文件格式，elf64-x86-64 表示在 64 位 x86 架构上执行的 ELF 文件；
* `ENTRY(_start)` 用于定义程序的入口地址，稍后就会看到，这里的 `_start` 是定义在 head.o 中的一个符号：
* `SECTIONS` 的部分，用来定义如何构建内核的结构；
  
首先，我们用 `.` 定义当前地址的值：

```shell
SECTIONS
{
    . = 0xFFFF800000000000 + 0x100000;
}
```

这里，`.` 的含义和之前我们用 nasm 的时候 `$` 的含义是类似的，表示当前地址。给 `.` 赋值相当于告诉 `ld` 在接下来的链接过程中，以 `0xFFFF800000100000` 为参考地址。通过这种方式，我们就定义了内核中所有符号的基地址。于是，把内核加载到 1MB 地址空间，并从 loader 跳转到内核之后，内核代码就可以正确执行了。如果你还想不太清楚这个过程也没关系，稍后，我们看看生成的内核，也就明白了。

接下来，我们链接内核的代码部分：

```shell
.text :
{
    _text = .;
    *(.text)
    _etext = .;
}
```

这里，`.text` 表示所有目标文件中，代码段的名称，这个名称是 GCC 工具链生成的，我们知道就好。在 `.text` 的大括号里，`_text` 和 `_etext` 分别表示 `ld` 生成的结果，也就是内核文件的代码段的开始和结束，而中间的 `*(.text)`，则表示用于构建内核的每一个目标文件的代码段。由于 `.text` 的部分紧挨着 `.` 的赋值语句，因此，代码段的第一条指令的地址，就是 `0xFFFF800000100000`。

了解了这种语法之后，定义数据段的方式就很简单了：

```shell
. = ALIGN(8);

.data :
{
    _data = .;
    *(.data)
    _edata = .;
}

.rodata :
{
    _rodata = .;
    *(.rodata)
    _erodata = .;
}

.bss :
{
    _bss = .;
    *(.bss)
    _ebss = .;
}
```

这次，为了让数据段的首地址在 8 字节边界对齐，我们使用了 `ALIGN` 指令。`.data / .rodata / .bss` 分别是 GCC 工具链对已初始化数据、只读数据和未初始化数据使用的段名称。我们在链接脚本要做的，就是把构建内核时使用的所有目标文件中相同的段，链接在一起。

最后，`_end = .;` 表示我们定义了一个叫做 `_end` 的符号，把它放在 `SECTIONS` 的最后一条语句，`.` 就表示内核最后一字节数据的下一个位置。用它减去 `0xFFFF800000100000`，就是内核的大小。

至此，链接内核使用的脚本就完成了。理解了它的含义之后，是不是就觉得一切都没那么神秘了？。接下来，我们来看看在上一节编写的 Makefile 中，是如何使用这个脚本的：

```shell
$(YUNASYSTEM): $(OBJS)
  $(info ========== Linking the kernel ==========)
  $(LD) -z muldefs -o $@ $(OBJS) -T Source/Kernel/kernel.lds
```

使用链接脚本的一个好处，就是可以省略不少通过命令行传递给 `ld` 的参数。这里：

* `-z muldefs`：表示允许在链接的过程中，多个目标文件包含同一个符号名称的定义，并默认使用第一个符号定义。至于为什么会有这种现象，等我们往后多实现几个内核组件之后找个机会再说；
* `-T` 用于指定链接使用的脚本文件；
* `-o` 是要生成的目标文件，也就是内核文件的名称；

## 查看链接结果

至此，链接脚本就写完了，通过 kernel.lds 生成的，是一个在 X86-64 平台上运行的 ELF 格式的文件。我们可以在项目根目录执行 `objdump -t Output/system` 看下执行的结果：

```shell
Output/system:	file format ELF64-x86-64

SYMBOL TABLE:
ffff800000100000 l    d  .text	00000000 .text
ffff8000001055c0 l    d  .data	00000000 .data
ffff800000108600 l    d  .got.plt	00000000 .got.plt
ffff800000108618 l    d  .rodata	00000000 .rodata
ffff800000108788 l    d  .eh_frame	00000000 .eh_frame
ffff8000001089c0 l    d  .bss	00000000 .bss
0000000000000000 l    d  .debug_info	00000000 .debug_info
```

这里，篇幅限制，我们只列出了一小部分。可以看到，`.text` 正是从 `ffff800000100000` 这个地址开始的。并且，除了 `.text / .data / .rodata / .bss` 这些段之外，还有一些叫做 `.got.plt / .eh_frame / .debug_info` 的符号，它们和异常处理以及调试相关，我们知道就好了。

## 简化内核结构

现在，虽然生成了 system，我们却不能直接把它加载到内存并执行。因为 system 是带有格式的，它的第一个字节并不是要执行的代码，而是 ELF 文件头。因此，把它加载到 1MB 地址之后，`.text` 代码段在内存中的实际位置并不是 1MB，这就导致了 system 中所有符号的位置，在内存中都是不正确的。我们从 loader 跳转到 1MB 内存之后，也无法执行任何代码。

因此，接下来要做的，有两件事情：

* 一个是去掉内核的 ELF 文件头，因为没有运行时来加载内核的文件头信息，我们需要让代码段直接处于内核的开始位置；
* 另一个，是去掉内核二进制文件中和代码以及数据无关的段，这样做可以减小内核的尺寸；

这两件事情，可以通过一个叫做 `objcopy` 的工具完成。这是上一节 Makefile 中最终生成内核文件的规则：

```shell
$(YUNAKERNEL): $(YUNASYSTEM)
  $(info ========== Remove extra sections of the kernel ==========)
  $(OBJCOPY) -S -R ".eh_frame" -R ".comment" -O binary $< $@
```

其中：

* `-S` 用于去掉 system 中的符号和重定位信息；
* `-R` 用于指定要删除的二进制段的名称；
* `-O` 用于设置生成的文件格式，binary 表示生成一个不带有任何格式的二进制文件；

经过这一番处理之后，生成的 kernel.bin 就可以直接加载到内存了。

## Makefile 中的其它细节

这一节最后，我们再来看看构建内核时用到的其它 Makefile 规则。一开始，对我们对重要的就是 head.s 和 main.c 的编译：

```shell
Output/main.o: Source/Kernel/main.c Source/Kernel/lib.h Source/Kernel/printk.h Source/Kernel/font.h
  $(info ========== Compiling main.c ==========)
  $(CC) -mcmodel=large -fno-builtin -ggdb -m64 -c $< -o $@

Output/head.o: Source/Kernel/head.S
  $(info ========== Building kernel head ==========)
  $(CC) -E $< > Output/_head.s
  $(AS) --64 -o $@ Output/_head.s
```

在编写 Makefile 规则的时候，通常文件的依赖关系列表会比较复杂，特别是引用的文件多了之后。这里，介绍一个简单的让 gcc 帮我们生成这个列表的方法。例如，为了生成从 main.c 到 main.o 的依赖关系，我们可以在项目根目录执行 `gcc -MM Source/Kernel/main.c`，然后，gcc 就会给我们返回依赖关系列表，我们直接把它黏贴到 Makefile 里就好了，很方便。

至于在编译 main.c 时使用的编译器选项：

* `-mcmodel=large` 表示不让 gcc 假定内存的大小，我们的内核应该有能力处理任意大小的物理内存；
* `-fno-builtin` 表示不让 gcc 使用任何内建的函数对代码进行优化，因为内核的执行环境没有 C 运行时支持，因此也没有这些内建函数可以使用；
* `-ggdb` 表示在目标文件中生成调试符号，方便我们稍后在 gdb 中进行调试；
* `-m64` 表示编译成 64 位代码；
* `-c` 表示只把源代码编译成目标文件，但是不链接。就像刚才我们看到的，所有目标文件的链接，是单独完成的；

然后，来看把 head.S 编译成 head.o 的过程。我们编写的 head.S 并不能被 `as` 直接编译，而是要先用 `gcc` 预处理一下。这里之所以预处理的结果用了 _head.s 而不是 head.s，主要是和 mac OS 里的文件名默认不区分大小写有关。如果用 head.s，在 mac OS 上就会覆盖掉我们的源代码文件，因此特意使用了一个不用的文件名，大家知道这个问题就好了。

> head.S 和 head.s 不是相同的文件，.S 是我们的源代码，.s 是 gcc 预处理过的源代码。

预处理之后，用 `as` 工具带上 `--64` 选项，就可以生成 64 位的 head.o 目标文件了。

## What's next

以上，就是和链接内核文件相关的内容。现在回过头看看，我们已经有了项目的构建脚本 Makefile，有了内核的组装指南 kernel.lds，是时候真的生成一个内核了。下一节，我们就动手实现这个目标。
