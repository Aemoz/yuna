# Gather memory and display info

之前我们说过，loader.bin 的工作有两部分：

* 一部分是把内核加载到内存，这部分功能已经完成了；
* 另一部分，是为内核准备好必要的系统信息。这一节，我们就来完成这部分内容；

## 读取内存信息

对于内核来说，系统信息中最关键的一部分，莫过于内存了。出于一些历史问题，看似“平坦”的内存地址空间实际上要复杂的多。哪些地址空间可用，哪些地址空间是空洞，哪些地址空间是保留或无效的，系统有多少物理内存可用，这些都是为了内核正常工作我们需要收集的信息。

这时，你一定会问，这些信息从哪来呢？

一个好消息是，BIOS 提供了获取内存信息的 API：`int 15H`。使用过这个中断时，我们要通过寄存器传递 5 个参数：

* `eax`：0x000E820，这是固定值；
* `ebx`：0x0000000，第一次调用 `int 15H` 时，这个值设定成 0，稍后，`ebx` 会在每一次 `int 15H` 之后变化；
* `ecx`：保存 `int 15H` 结果的缓冲区大小，这个缓冲区应该大于等于 20 字节；
* `edx`：0x534D4150，这是固定值；
* `es:di`：指向保存 `int 15` 结果的缓冲区；

做好这些准备之后，调用 `int 15H`，如果 `EFLAGS.CF` 标志为 0，表示调用成功，此时：

* `eax`：0x534D4150，这个值和调用时的 `edx` 相同；
* `ebx`：每次调用 `int 15H`，`ebx` 会包含一个用于下次 `int 15H` 必须传递的值，我们无需关心这个值具体是什么，它就像个令牌一样，在多个 `int 15H` 之间传递，直到某一次 `int 15H` 之后 `ebx` 又变成 0，就表示所有内存信息都读完了；
* `ecx`： 保存内存信息的结构体的实际长度；
* `es:di`：指向内存信息；

如果 `EFLAGS.CF` 标志为 1，则表示调用失败，此时 `AH` 寄存器包含了具体的错误代码。了解了 `int 15H` 的用法之后，我们来看代码：

```asm
MEMORY_INFO_BUFFER equ 0x7E00
    mov ebx, 0
    mov ax, 0
    mov es, ax
    mov di, MEMORY_INFO_BUFFER

_load_mem_info:
    mov eax, 0E820H
    mov ecx, 20
    mov edx, 534D4150H
    int 15H
    jc _load_mem_info_failed
    add di, 20
    cmp ebx, 0
    jne _load_mem_info
    jmp _load_mem_info_successed
```

可以看到，我们让 `es:di` 指向了 `0x7E00`，也就是之前我们搬运内核时使用的临时地址，现在这个地址已经没用了，我们可以继续用它保存内存信息。就像刚才说过的，只要 `EFLAGS.CF` 不等于 1，我们就一直调用 `int 15H`，然后，把缓冲区加 20 就好了。

至于这个缓冲区里面的内容，我们暂时无需关心。等稍后为内核构建内存页表的时候，再来详细了解它的内部结构，现在我们还是把注意力专注在读取各种系统信息上，只要记住 **`0x7E00` 这个地址开始保存的是物理内存信息就好了**。

## 读取 VESA 信息

读取了内存信息，第二个要设置的，就是显示器的工作模式。毕竟，80 x 25 的字符模式可以让我们显示的内容太少。为了使用更大的分辨率，以及开发 GUI，在 loader 里，我们要做一些必要的工作。首先，就是通过上一节提到的 VBE，读取显示器支持的工作模式，这个 API 是这样的：

```asm
; Write VBE controller info into es:di
xor ax, ax
mov es, ax
mov di, 8000H
mov ax, 4F00H
int 10H
```

其中：

* `ax` 是功能号，VBE 的所有功能，都以 0x4F 开头，而后面的 00，表示查询显示器工作模式；
* `es:di` 指向查询结果的缓冲区，这次，我们选择的地址是 0x8000；

调用完成后，如果执行成功了，`al` 寄存器的值会是 `4F`，这是所有 VBE 调用的约定。而 `es:di` 则指向了一个表达 VBE 控制器信息的结构，如果你是第一次编写 VBE 相关的代码，此时不妨在执行完 `int 10H` 之后，把 CPU 断下来，看看这部分内存里实际的数据，如果你也使用 bochs，那么它看上去，应该是类似这样的：

```shell
(0) [0x0000000101f8] 1000:01f8 (unk. ctxt): int 0x10                  ; cd10
<bochs:6> n
Next at t=15746333
(0) [0x0000000101fa] 1000:01fa (unk. ctxt): cmp ax, 0x004f            ; 83f84f
<bochs:7> x /32bx es:di
[bochs]:
0x0000000000008000 <bogus+       0>:	0x56	0x45	0x53	0x41	0x00	0x02	0x48	0x93
0x0000000000008008 <bogus+       8>:	0x00	0xc0	0x01	0x00	0x00	0x00	0x22	0x80
0x0000000000008010 <bogus+      16>:	0x00	0x00	0x00	0x01	0x00	0x00	0x00	0x00
0x0000000000008018 <bogus+      24>:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
```

这里，有几个重要的字段是我们需要关注的：

* 0x8000 开始的四字节，是字符串 `VESA`，这是 VBE 控制器信息结构的起始标志；
* 0x800A 开始的四字节，表示图形控制器支持的硬件能力，这里 `0x00000001` 表示显示字符时，每个字符的颜色属性占据 8-bit。至于其他的硬件能力，我们暂时还无需了解，大家知道这个字段的含义就好了；
* 0x800E 开始的四字节，是一个内存地址，在 Bochs 里，这个值是 0x8022。这个地址保存了 VBE 控制器支持的所有显示模式编号，稍后，我们会用这个编号，去查询每种显示模式的详细信息，因此，现在大家知道它的含义就好了；
* 0x8012 开始的两字节，是系统中显存的数量，0x100，表示 64KB 显存；

至于 VBE 控制器信息结构的其它成员，和我们当前的操作关系不大，我们就先忽略掉了。接下来要做的，就是根据刚才提到的 0x8022 处的显示模式编号列表的地址，读取每一种显示模式的详细信息，这是通过 VBE 的 `4F01` 号功能实现的：

```asm
    xor ax, ax
    mov es, ax
    mov si, 800EH
    mov esi, dword [es:si]
    mov edi, 8200H

_vga_mode_list:
    mov cx, word [es:esi]

    push ax
    xor ax, ax
    mov al, ch
    call disp_al

    xor ax, ax
    mov al, cl
    call disp_al

    xor ax, ax
    mov al, ' '
    call disp_ascii
    pop ax

    cmp cx, 0FFFFH
    jz _finish_loading_svga_mode

    mov ax, 4F01H
    int 10h
    cmp ax, 004FH
    jnz _load_svga_mode_failed

    add esi, 2
    add edi, 0x100
    jmp _vga_mode_list
```

在上面这段代码里，我们先读取一个模式编号，保存在了 `cx` 里，并通过上一节编写的方法，把它打印在了屏幕上，这个列表的最后一个值，是 0xFFFF，如果结束了，就跳转到 `_finish_loading_svga_mode`。否则，就是还有更多模式等待读取。这里，我们先看一下这个模式列表的样子：

![gather-mem-and-disp-info-1](Images/gather-mem-and-disp-info-1@2x.jpg)

看到了吧，每个模式编号，就是一个 4 字节的数字而已。为了读取和模式编号对应的显示模式信息，我们要设置好这些寄存器：

* `ax`：0x4501，功能的 VBE 功能编号；
* `cx`：刚才我们说到的显示模式编号；
* `es:di`：保存显示模式信息的缓冲区地址，在我们的代码里，这个地址是 0x8200；

每一个模式的详细显示信息结构，都是 255 字节，因此，每读完一个模式，我们要给 `edi` 加 0x100 偏移。这样，等读到 0xFFFF，就表示所有模式都读完了。这里，和刚才读取 VBE 控制器信息类似，我们只是说一下每条显示模式信息中，值得关注的字段：

* 首先，是偏移 18 的两字节，表示该模式下的水平分辨率；
* 其次，是偏移 20 的两字节，表示该模式下的垂直分辨率；
* 最后，是偏移 40 的 4 字节，表示该模式下 frame buffer 的起始物理地址；

这里，我们用第一种显示模式：0x0100 举例，来看下这个结构中的实际内容：

```shell
<bochs:2>  x /50bx 0x8200       
[bochs]:
0x0000000000008200 <bogus+       0>:    0x9b    0x00    0x07    0x00    0x40    0x00    0x40    0x00
0x0000000000008208 <bogus+       8>:    0x00    0xa0    0x00    0x00    0x97    0x96    0x00    0xc0
0x0000000000008210 <bogus+      16>:    0x80    0x02    0x80    0x02    0x90    0x01    0x08    0x10
0x0000000000008218 <bogus+      24>:    0x01    0x08    0x04    0x04    0x00    0x40    0x00    0x00
0x0000000000008220 <bogus+      32>:    0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x0000000000008228 <bogus+      40>:    0x00    0x00    0x00    0xe0    0x00    0x00    0x00    0x00
0x0000000000008230 <bogus+      48>:    0x00    0x00
```

* 偏移 18 处的两字节是 0x208，也就是说水平分辨率是 640；
* 偏移 20 处的两字节是 0x090，也就是说垂直分辨率是 400，因此，该模式对应的分辨率，就是 640 x 400；
* 偏移 40 处的四字节是 0xE0000000，这是该模式下 frame buffer 的基地址；

当然，如果大家感兴趣，可以把每一种显示模式对应的分辨率和基地址都打印出来。不过我们就省略这一步了，大家知道如何使用 VBE 0x4F00 和 0x4F01 查询信息就好。

## 设置 VESA 显示模式

接下来，我们要给 Bochs 的显示器设置一个合适个显示模式。这里，我们可以根据自己的喜好，选择两种常用的模式号（当然，你也可以自己遍历所有的模式找到自己期望的分辨率）：

* 0x180：表示 1440 x 900 分辨率；
* 0x118：表示 1024 x 768 分辨率；

为了切换到上面两种模式，我们可以使用 `int 10H` 的 4F02 号功能：

```asm
mov ax, 4F02H
mov bx, 4180H ; 1440 * 900
int 10H

cmp ax, 004FH
jz _set_svga_mode_successed
```

可以看到，在使用 4F02 号功能时，`bx` 中除了要设置的模式号之外，最高字节的 4 表示使用线性 frame buffer 模式，至于 `bx` 其它位的含义，不影响当前 loader 的开发，大家只要记住让 `bx` 是 `4+模式号` 就好了。

这样一来，当切换了显示模式之后，显示器就从字符模式，切换到图形模式了，之前显示在字符模式的内容，也都会清空。此时的 Bochs 看上去是这样的：

![gather-mem-and-disp-info-2](Images/gather-mem-and-disp-info-2@2x.jpg)

## What's next

至此，在我们进一步为图形模式开发打印程序库之前，暂时就无法为在屏幕上显示任何内容了（别担心，这个过程不会太久）。要调试的话，我们可以通过 Bochs 内部的调试器。下一节，我们完成切换到内核的最后一部分准备工作，并把计算机控制权交给内核。
